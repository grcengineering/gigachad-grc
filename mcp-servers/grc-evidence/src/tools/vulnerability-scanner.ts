import { spawn } from 'child_process';
import axios from 'axios';

/**
 * SECURITY: Helper to execute commands safely using spawn with argument arrays
 * This prevents command injection by keeping arguments separate from the command
 */
async function spawnAsync(
  command: string,
  args: string[],
  options: { maxBuffer?: number; timeout?: number; cwd?: string } = {}
): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      cwd: options.cwd,
      timeout: options.timeout,
      maxBuffer: options.maxBuffer,
      shell: false, // SECURITY: Explicitly disable shell to prevent injection
    });

    let stdout = '';
    let stderr = '';

    child.stdout?.on('data', (data) => {
      stdout += data.toString();
    });

    child.stderr?.on('data', (data) => {
      stderr += data.toString();
    });

    child.on('error', (error) => {
      reject(error);
    });

    child.on('close', (code) => {
      if (code === 0) {
        resolve({ stdout, stderr });
      } else {
        const error = new Error(`Command exited with code ${code}: ${stderr}`);
        (error as any).code = code;
        reject(error);
      }
    });
  });
}

/**
 * SECURITY: Validate and sanitize input for command arguments
 * Blocks shell metacharacters that could enable command injection
 */
function validateCommandInput(input: string, inputName: string): void {
  // Block shell metacharacters
  const dangerousChars = /[;&|`$(){}[\]<>!\\]/;
  if (dangerousChars.test(input)) {
    throw new Error(`SECURITY: Invalid ${inputName} - contains shell metacharacters`);
  }
  
  // Block newlines which could enable command injection
  if (/[\n\r]/.test(input)) {
    throw new Error(`SECURITY: Invalid ${inputName} - contains newline characters`);
  }
  
  // Limit length to prevent buffer overflow attacks
  if (input.length > 1000) {
    throw new Error(`SECURITY: Invalid ${inputName} - exceeds maximum length`);
  }
}

interface VulnerabilityScanParams {
  scanType: 'container' | 'dependency' | 'network' | 'web';
  target: string;
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'all';
}

interface ScanResult {
  type: string;
  target: string;
  collectedAt: string;
  vulnerabilities: Vulnerability[];
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    total: number;
  };
  scanDuration: number;
  isMockMode?: boolean;
  mockModeReason?: string;
  toolsRequired?: string[];
}

interface Vulnerability {
  id: string;
  severity: string;
  title: string;
  description?: string;
  package?: string;
  version?: string;
  fixedVersion?: string;
  cvss?: number;
  references?: string[];
}

export async function scanVulnerabilities(params: VulnerabilityScanParams): Promise<ScanResult> {
  const { scanType, target, severity = 'all' } = params;
  const startTime = Date.now();

  try {
    let result: ScanResult;

    switch (scanType) {
      case 'container':
        result = await scanContainer(target, severity);
        break;
      case 'dependency':
        result = await scanDependencies(target, severity);
        break;
      case 'network':
        result = await scanNetwork(target, severity);
        break;
      case 'web':
        result = await scanWebApplication(target, severity);
        break;
      default:
        throw new Error(`Unknown scan type: ${scanType}`);
    }

    result.scanDuration = Date.now() - startTime;
    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`Vulnerability scan failed: ${errorMessage}`);
    
    return {
      type: scanType,
      target,
      collectedAt: new Date().toISOString(),
      vulnerabilities: [],
      summary: { critical: 0, high: 0, medium: 0, low: 0, total: 0 },
      scanDuration: Date.now() - startTime,
      isMockMode: true,
      mockModeReason: `Scan failed: ${errorMessage}`,
    };
  }
}

async function scanContainer(image: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];
  let isMockMode = false;
  let mockModeReason: string | undefined;
  
  try {
    // SECURITY: Validate inputs to prevent command injection
    validateCommandInput(image, 'image name');
    validateCommandInput(severity, 'severity');
    
    // SECURITY: Use spawn with argument array instead of exec with string concatenation
    // This prevents command injection by keeping arguments separate
    const severityArg = severity === 'all' ? 'CRITICAL,HIGH,MEDIUM,LOW' : severity.toUpperCase();
    const { stdout } = await spawnAsync('trivy', [
      'image',
      '--format', 'json',
      '--severity', severityArg,
      image,
    ], { maxBuffer: 50 * 1024 * 1024 });

    const scanResults = JSON.parse(stdout);
    
    for (const result of scanResults.Results || []) {
      for (const vuln of result.Vulnerabilities || []) {
        vulnerabilities.push({
          id: vuln.VulnerabilityID,
          severity: vuln.Severity.toLowerCase(),
          title: vuln.Title || vuln.VulnerabilityID,
          description: vuln.Description,
          package: `${result.Target}/${vuln.PkgName}`,
          version: vuln.InstalledVersion,
          fixedVersion: vuln.FixedVersion,
          cvss: vuln.CVSS?.nvd?.V3Score,
          references: vuln.References,
        });
      }
    }
  } catch {
    // Trivy not available - provide clear guidance
    isMockMode = true;
    mockModeReason = 'Trivy container scanner not installed. Install from: https://aquasecurity.github.io/trivy/';
    
    console.warn(`Container scan running in demo mode: ${mockModeReason}`);
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'container',
    target: image,
    collectedAt: new Date().toISOString(),
    vulnerabilities,
    summary,
    scanDuration: 0,
    isMockMode,
    mockModeReason,
    toolsRequired: isMockMode ? ['trivy'] : undefined,
  };
}

async function scanDependencies(projectPath: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];
  let isMockMode = false;
  let mockModeReason: string | undefined;
  const toolsRequired: string[] = [];

  // SECURITY: Validate inputs to prevent command injection
  validateCommandInput(projectPath, 'project path');
  validateCommandInput(severity, 'severity');

  try {
    // SECURITY: Use spawn with cwd option instead of cd command
    // This prevents command injection by keeping arguments separate
    const { stdout } = await spawnAsync('npm', ['audit', '--json'], {
      cwd: projectPath,
      maxBuffer: 10 * 1024 * 1024,
    });

    const auditResults = JSON.parse(stdout);
    
    for (const [, advisory] of Object.entries(auditResults.advisories || {})) {
      const adv = advisory as Record<string, unknown>;
      const advSeverity = (adv.severity as string).toLowerCase();
      
      if (severity !== 'all' && advSeverity !== severity) continue;

      vulnerabilities.push({
        id: `GHSA-${adv.id}`,
        severity: advSeverity,
        title: adv.title as string,
        description: adv.overview as string,
        package: adv.module_name as string,
        version: (adv.findings as Array<{ version: string }>)?.[0]?.version,
        fixedVersion: adv.patched_versions as string,
        references: [adv.url as string],
      });
    }
  } catch {
    // npm audit not available or failed, try other package managers
    try {
      // SECURITY: Use spawn with cwd option for pip-audit
      const { stdout } = await spawnAsync('pip-audit', ['--format=json'], {
        cwd: projectPath,
        maxBuffer: 10 * 1024 * 1024,
      });

      const auditResults = JSON.parse(stdout);
      for (const vuln of auditResults) {
        vulnerabilities.push({
          id: vuln.id,
          severity: vuln.fix_versions?.length ? 'medium' : 'high',
          title: `${vuln.name} vulnerability`,
          description: vuln.description,
          package: vuln.name,
          version: vuln.version,
          fixedVersion: vuln.fix_versions?.join(', '),
        });
      }
    } catch {
      // No dependency scanner available
      isMockMode = true;
      mockModeReason = 'No dependency scanner available. Install npm (for Node.js) or pip-audit (for Python) for actual scanning.';
      toolsRequired.push('npm', 'pip-audit');
      
      console.warn(`Dependency scan running in demo mode: ${mockModeReason}`);
    }
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'dependency',
    target: projectPath,
    collectedAt: new Date().toISOString(),
    vulnerabilities,
    summary,
    scanDuration: 0,
    isMockMode,
    mockModeReason,
    toolsRequired: isMockMode ? toolsRequired : undefined,
  };
}

async function scanNetwork(target: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];
  let isMockMode = false;
  let mockModeReason: string | undefined;

  // SECURITY: Validate inputs to prevent command injection
  validateCommandInput(target, 'network target');
  validateCommandInput(severity, 'severity');

  try {
    // SECURITY: Use spawn with argument array instead of exec with string concatenation
    const { stdout } = await spawnAsync('nmap', [
      '-sV',
      '-sC',
      '--script', 'vuln',
      target,
      '-oX', '-',
    ], { maxBuffer: 10 * 1024 * 1024, timeout: 300000 });

    // Parse nmap XML output (simplified)
    // In a real implementation, use an XML parser
    if (stdout.includes('VULNERABLE')) {
      const vulnMatches = stdout.match(/CVE-\d{4}-\d+/g) || [];
      for (const cve of [...new Set(vulnMatches)]) {
        vulnerabilities.push({
          id: cve,
          severity: 'high',
          title: `Network vulnerability: ${cve}`,
          description: 'Detected by nmap vulnerability scan',
          package: target,
        });
      }
    }
  } catch {
    // nmap not available - provide clear guidance
    isMockMode = true;
    mockModeReason = 'Nmap network scanner not installed. Install from: https://nmap.org/download.html';
    
    console.warn(`Network scan running in demo mode: ${mockModeReason}`);
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'network',
    target,
    collectedAt: new Date().toISOString(),
    vulnerabilities: filterBySeverity(vulnerabilities, severity),
    summary,
    scanDuration: 0,
    isMockMode,
    mockModeReason,
    toolsRequired: isMockMode ? ['nmap'] : undefined,
  };
}

async function scanWebApplication(url: string, severity: string): Promise<ScanResult> {
  const vulnerabilities: Vulnerability[] = [];

  try {
    // Basic security header checks
    const response = await axios.get(url, {
      timeout: 30000,
      validateStatus: () => true,
    });

    const headers = response.headers;

    // Check for security headers
    const securityHeaders = {
      'strict-transport-security': {
        present: !!headers['strict-transport-security'],
        severity: 'high',
        title: 'Missing HSTS Header',
      },
      'content-security-policy': {
        present: !!headers['content-security-policy'],
        severity: 'medium',
        title: 'Missing Content Security Policy',
      },
      'x-frame-options': {
        present: !!headers['x-frame-options'],
        severity: 'medium',
        title: 'Missing X-Frame-Options Header',
      },
      'x-content-type-options': {
        present: !!headers['x-content-type-options'],
        severity: 'low',
        title: 'Missing X-Content-Type-Options Header',
      },
      'x-xss-protection': {
        present: !!headers['x-xss-protection'],
        severity: 'low',
        title: 'Missing X-XSS-Protection Header',
      },
      'referrer-policy': {
        present: !!headers['referrer-policy'],
        severity: 'low',
        title: 'Missing Referrer-Policy Header',
      },
    };

    for (const [header, config] of Object.entries(securityHeaders)) {
      if (!config.present) {
        vulnerabilities.push({
          id: `WEB-${header.toUpperCase().replace(/-/g, '_')}`,
          severity: config.severity,
          title: config.title,
          description: `The ${header} security header is not set`,
          package: url,
          references: [`https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/${header}`],
        });
      }
    }

    // Check for information disclosure
    if (headers['server']) {
      vulnerabilities.push({
        id: 'WEB-SERVER-DISCLOSURE',
        severity: 'low',
        title: 'Server Version Disclosure',
        description: `Server header reveals: ${headers['server']}`,
        package: url,
      });
    }

    if (headers['x-powered-by']) {
      vulnerabilities.push({
        id: 'WEB-POWERED-BY-DISCLOSURE',
        severity: 'low',
        title: 'Technology Stack Disclosure',
        description: `X-Powered-By header reveals: ${headers['x-powered-by']}`,
        package: url,
      });
    }

    // Check TLS (if HTTPS)
    if (url.startsWith('https://')) {
      // In a real implementation, you would check certificate validity, cipher suites, etc.
      vulnerabilities.push({
        id: 'WEB-TLS-CHECK',
        severity: 'info',
        title: 'TLS Configuration',
        description: 'HTTPS is enabled. For detailed TLS analysis, use tools like testssl.sh',
        package: url,
      });
    } else {
      vulnerabilities.push({
        id: 'WEB-NO-HTTPS',
        severity: 'critical',
        title: 'No HTTPS',
        description: 'The application is not using HTTPS encryption',
        package: url,
      });
    }
  } catch (error) {
    vulnerabilities.push({
      id: 'WEB-SCAN-ERROR',
      severity: 'info',
      title: 'Web Scan Error',
      description: error instanceof Error ? error.message : 'Failed to scan web application',
      package: url,
    });
  }

  const summary = calculateSummary(vulnerabilities);

  return {
    type: 'web',
    target: url,
    collectedAt: new Date().toISOString(),
    vulnerabilities: filterBySeverity(vulnerabilities, severity),
    summary,
    scanDuration: 0,
  };
}

function calculateSummary(vulnerabilities: Vulnerability[]): {
  critical: number;
  high: number;
  medium: number;
  low: number;
  total: number;
} {
  return {
    critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
    high: vulnerabilities.filter((v) => v.severity === 'high').length,
    medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
    low: vulnerabilities.filter((v) => v.severity === 'low' || v.severity === 'info').length,
    total: vulnerabilities.length,
  };
}

function filterBySeverity(
  vulnerabilities: Vulnerability[],
  severity: string
): Vulnerability[] {
  if (severity === 'all') return vulnerabilities;

  const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
  const minSeverityIndex = severityOrder.indexOf(severity);

  return vulnerabilities.filter((v) => {
    const vulnSeverityIndex = severityOrder.indexOf(v.severity);
    return vulnSeverityIndex <= minSeverityIndex;
  });
}




